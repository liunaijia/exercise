1
派生类从基类继承了：
除构造函数、析构函数外的所有protected和public成员。

2
派生类不能从基类继承构造函数、析构函数。

3
baseDMA::operator=()返回void将无法使用连续赋值，如a = b =c；
如果返回baseDMA对象，而不是引用，将导致baseDMA的复制构造函数被调用，生成一个临时对象，然后将这个临时对象赋值给某个变量，然后再销毁临时对象，效率比较低。

4
创建派生类对象，先调用基类的构造函数，再调用派生类的构造函数；
删除派生类对象，先调用派生类的析构函数，在调用基类的析构函数。

5
如果派生类没有添加任何数据成员，它可能需要构造函数，用来调用基类的非默认构造函数进行基类数据成员初始化，否则就可以不定义构造函数，无论派生类还是基类，都使用默认构造函数。

6
基类和派生类定义了同名方法，当派生类对象调用该方法时：
* 如果这是个虚方法，那么体现为动态联编多态特性，根据运行时对象的类型调用函数；
* 如果不是虚方法，则根据变量声明时的类型调用其方法。

7
一个最常见的情况，派生类的构造函数中使用new为自身成员变量分配了内存，这时就需要派生类定义自己的operator=。

8
当然可以将派生类对象的地址赋给基类指针，反之则不一定，看派生类是否定义了operator=(基类指针)函数了

9
可以将派生类对象赋值给基类对象吗？看基类的是否定义了接受一个派生类对象的构造函数，或者基类定义了operator=(派生类对象)，不过题目问的是赋值，只有第二个方法可行。
可以将基类对象赋值给派生类对象吗？看派生类中是否定义了operator=(基类对象)的方法。

10
派生类对象可以隐士转换为派生类对象引用，再隐式转换为基类对象引用。

11
派生类对象会隐式转换为派生类对象引用，基类默认会生成复制构造函数(const 基类对象引用)，派生类对象引用可隐式转换为基类对象引用，所以派生类对象变成基类对象传递给参数。

12
按照值传递，一般需要：使用复制构造函数创建临时对象，调用operator=进行赋值，再销毁临时对象。

14
House::House()中，使用了未赋值的变量all_sql_ft，另外无法访问基类的私有成员kti_sq_ft。
House::area(const char* s)并没有重写基类的虚函数，当然这并不是必须的。
用House集成Kitchen就是个错误，它们并不是is a关系，应该是House has-a kitchen。