package constantpool;

import java.io.IOException;

import bytecode.ByteCodeReader;

public abstract class ConstantPoolInfo {
	/**
	 * 常量占用的常量池空间
	 * All 8-byte constants take up two entries in the constant_pool table of the class file. If a CONSTANT_Long_info or CONSTANT_Double_info structure is the item in the constant_pool table at index n, then the next usable item in the pool is located at index n+2. The constant_pool index n+1 must be valid but is considered unusable
	 * @return
	 */
	public int entrySize(){
		return 1;
	}
	
	public static ConstantPoolInfo instance(ByteCodeReader reader) throws IOException {
		ConstantPoolInfo constantPoolInfo;
		
		int tag = reader.read1u();
		switch(tag) {
			case 1:
				constantPoolInfo = new ConstantUtf8Info(reader);
				break;
			case 3:
				constantPoolInfo = new ConstantIntegerInfo(reader);
				break;
			case 4:
				constantPoolInfo = new ConstantFloatInfo(reader);
				break;
			case 5:
				constantPoolInfo = new ConstantLongInfo(reader);
				break;
			case 6:
				constantPoolInfo = new ConstantDoubleInfo(reader);
				break;
			case 7:
				constantPoolInfo = new ConstantClassInfo(reader);
				break;
			case 8:
				constantPoolInfo = new ConstantStringInfo(reader);
				break;
			case 10:
				constantPoolInfo = new ConstantMethodRefInfo(reader);
				break;
			case 12:
				constantPoolInfo = new ConstantNameAndTypeInfo(reader);
				break;
			default:
				throw new ClassFormatError(String.format("invalid constant pool tag %d", tag));
		}
		
		return constantPoolInfo;
	}
}